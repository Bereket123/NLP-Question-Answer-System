database_design_decisions: 
this document is a sketch of the intended structure of the entity factoid database


|=== Detailed Dictionary of Relations =========|

table
lookup : hash name_entity -> list of general properties & relative frequency
|---Entity---|---GeneralizedParsedProperty,relFreq(count of property/properties of entity)---|
             |---GeneralizedParsedProperty,relFreq(count of property/properties of entity)---|
   	     |---GeneralizedParsedProperty,relFreq(count of property/properties of entity)---|

lookup : hash entity_property -> list of raw string
|---EntityProperty---|---start/end index of string (not ordered)---|

Expected input:
no pronouns ie cataphora (?) resolution complete
parsed by named entity & phrasal separation
ideally, passed in as tuple of (entity, key property, raw string)

Requires:
raw string file unchanged

Notes:
think about uniary, binary, trinary relations etc.

Tools:
intern(string) gain a little performance on dictionary lookup
nltk noun-phase chunking


|== Alternative =============================|
|-- Quick & Dirty Parsing -------------------|
sparse model matrix of all named entities / nouns 
if relation exists, map to raw string sentence index

Pro: saves time, especially for answering task where detailed 
     relations not necessary for most pairs, only for goal entity
     places emphasis on computation at answer generation time, rather than 
     inital parsing. if add frequency, sufficient also for question generation
Cons: less information stored / availible immediately
Compromise: used different database for question vs answer task?

NoteToSelf: memory comparision, extreme sparsity & minimal info vs high volume detail dictionary







